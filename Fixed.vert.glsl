#version 330 core


#undef FLAT_SHADING


// Input vertex data, different for all executions of this shader.
layout(location = 0) in vec3 vertexPosition_modelspace;
layout(location = 1) in vec2 vertexUV;
layout(location = 2) in vec3 vertexNormal_modelspace;

// Output data ; will be interpolated for each fragment.
out vec2 UV;
#ifdef FLAT_SHADING
out vec4 color_part; // all colors will be computed in fragment shader
#endif

flat out vec3 lightVec_viewspace[2];
out vec3 normal_viewspace;
out vec3 normal_modelspace;
out vec3 reflectVec_viewspace[2]; // not sure whether it's valid to interpolate this... if it introduces an error, it is imperceptible so far

// Values that stay constant for the whole mesh.
uniform mat4 MVP;
uniform mat4 MV;
uniform mat4 M;
uniform mat4 V;
uniform mat3 N; // normal matrix

uniform vec4 lightPosition_worldspace[2];
uniform float light_constantAttenuation[2];
uniform float light_linearAttenuation[2];
uniform float light_quadraticAttenuation[2];
uniform vec4 light_ambient[2];
uniform vec4 light_diffuse[2];
uniform vec4 light_specular[2];

uniform int shininess;
uniform vec4 sceneColor;
uniform float ambient;
uniform float diffuse;
uniform float specular;

uniform vec3 eye_position;;

///*******************************************************
//*  Fixed.vert Fixed Function Equivalent Vertex Shader  *
//*   Automatically Generated by 3Dlabs GLSL ShaderGen   *
//*             http://developer.3dlabs.com              *
//*******************************************************/
vec4 Ambient;
vec4 Diffuse;
vec4 Specular;


void pointLight(in int i, in vec3 normal, in vec3 eye, in vec3 ecPosition3)
{
   float nDotVP;       // normal . light direction
   float nDotHV;       // normal . light half vector
   float pf;           // power factor
   float attenuation;  // computed attenuation factor
   float d;            // distance from surface to light source
   vec3  VP;           // direction from surface to light position
   vec3  halfVector;   // direction of maximum highlights

   //float derp = max(0.0, dot(normal, -ecPosition3));
   //Diffuse += light_diffuse[i] * derp;
   //return;

   // Compute vector from surface to light position
   VP = vec3(V * lightPosition_worldspace[i]) - ecPosition3;

   // Compute distance between surface and light position
   d = length(VP);

   // Normalize the vector from surface to light position
   VP = normalize(VP);

   // Compute attenuation
#if 0
   attenuation = 1.0 / (light_constantAttenuation[i] +
       light_linearAttenuation[i] * d +
       light_quadraticAttenuation[i] * d * d);
#endif
   attenuation = 1.0 / (light_quadraticAttenuation[i] * d * d);

   halfVector = normalize(VP + eye);

   nDotVP = max(0.0, dot(normal, VP));
   nDotHV = max(0.0, dot(normal, halfVector));

   if (nDotVP == 0.0)
   {
       pf = 0.0;
   }
   else
   {
       pf = pow(nDotHV, shininess);

   }
   Ambient  += light_ambient[i] * attenuation;
   Diffuse  += light_diffuse[i] * nDotVP * attenuation;
   Specular += light_specular[i] * pf * attenuation;
}

void directionalLight(in int i, in vec3 normal)
{
   float nDotVP;         // normal . light direction
   //float nDotHV;         // normal . light half vector
   float pf;             // power factor

   vec3 lightVec =  normalize( vec3(V * lightPosition_worldspace[i]) );

#ifdef FLAT_SHADING
   nDotVP = max( 0.0, dot(normal, lightVec) );
#endif

   // Eye vector (towards the camera)
   vec3 E = vec3(0.0, 0.0, 1.0);
   // Direction in which the triangle reflects the light
   vec3 R = reflect(-lightVec, normal);
   // Cosine of the angle between the Eye vector and the Reflect vector,
   // clamped to 0
   //  - Looking into the reflection -> 1
   //  - Looking elsewhere -> < 1
#ifdef FLAT_SHADING
   float cosAlpha = clamp( dot(E, R), 0, 1 );

   //nDotHV = max(0.0, dot(normal, vec3 (light_.halfVector)))[i];
   //nDotHV = max(0.0, dot(normal, vec3 (V * vec4(0.0, 1.0, 0.0, 0.0))));

   if (nDotVP == 0.0)
   {
       pf = 0.0;
   }
   else
   {
       pf = pow(cosAlpha, shininess);
   }
   Specular += light_specular[i] * pf;
   Diffuse  += light_diffuse[i] * nDotVP;
#else
   lightVec_viewspace[i] = lightVec;
   reflectVec_viewspace[i] = R;
#endif
   Ambient  += light_ambient[i];


}


vec3 fnormal(void)
{
	normal_modelspace = vertexNormal_modelspace;
    // Compute the normal 
    vec3 normal = N * vertexNormal_modelspace;
    // vec3 normal = (MV * vec4(vertexNormal_modelspace, 0)).xyz; // not compatible with non-uniform scaling!
    normal = normalize(normal);

	// pass it on to the fragment shader:
	normal_viewspace = normal;

    return normal;
}

/*
void ftexgen(in vec3 normal, in vec4 ecPosition)
{

    gl_TexCoord[0].s = dot( gl_Vertex, gl_ObjectPlaneS[0] );
    gl_TexCoord[0].t = dot( gl_Vertex, gl_ObjectPlaneT[0] );
    gl_TexCoord[0].p = dot( gl_Vertex, gl_ObjectPlaneR[0] );
    gl_TexCoord[0].q = dot( gl_Vertex, gl_ObjectPlaneQ[0] );
}
*/

void light(in vec3 normal, in vec4 ecPosition, float alphaFade)
{
    vec4 color;
    vec3 ecPosition3;
    vec3 eye;

    ecPosition3 = (vec3 (ecPosition)) / ecPosition.w;
    eye = vec3 (0.0, 0.0, 1.0);

    // Clear the light intensity accumulators
    Ambient  = vec4 (0.0);
    Diffuse  = vec4 (0.0);
    Specular = vec4 (0.0);

    //pointLight(0, normal, eye, ecPosition3);

    //pointLight(1, normal, eye, ecPosition3);

    directionalLight(0, normal);

#ifdef FLAT_SHADING
    color = sceneColor +
      Ambient  * ambient +
      Diffuse  * diffuse;
    color += Specular * specular;
    color = clamp( color, 0.0, 1.1 );
    color_part = color;
#endif
}


void main (void)
{
    vec3  transformedNormal;
    float alphaFade = 1.0;

    // Eye-coordinate position of vertex, needed in various calculations
    vec4 ecPosition = MV * vec4(vertexPosition_modelspace,1);

    // Do fixed functionality vertex transform
    transformedNormal = fnormal();
    light(transformedNormal, ecPosition, alphaFade);
    //ftexgen(transformedNormal, ecPosition);
    gl_Position = MVP * vec4(vertexPosition_modelspace,1);
	UV = vertexUV;
}
