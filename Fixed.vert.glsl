#version 330 core


#undef FLAT_SHADING


// Input vertex data, different for all executions of this shader.
layout(location = 0) in vec3 vertexPosition_modelspace;
layout(location = 1) in vec2 vertexUV;
layout(location = 2) in vec3 vertexNormal_modelspace;

// Output data ; will be interpolated for each fragment.
out vec2 UV;
out vec4 color_part;

flat out vec3 lightVec_viewspace[2];
out vec3 normal_viewspace;
out vec3 normal_modelspace;
flat out vec3 halfVec_directionalLight_viewspace[2]; 
out vec3 toLight_viewspace[2];

// Values that stay constant for the whole mesh.
uniform mat4 MVP;
uniform mat4 MV;
uniform mat4 M;
uniform mat4 V;
uniform mat3 N; // normal matrix

uniform vec4 lightPosition_worldspace[2];
uniform float light_constantAttenuation[2];
uniform float light_linearAttenuation[2];
uniform float light_quadraticAttenuation[2];
uniform vec4 light_ambient[2];
uniform vec4 light_diffuse[2];
uniform vec4 light_specular[2];

uniform int shininess;
uniform vec4 sceneColor;
uniform float ambient;
uniform float diffuse;
uniform float specular;

const vec3 eye = vec3 (0.0, 0.0, 1.0);

///*******************************************************
//*  Fixed.vert Fixed Function Equivalent Vertex Shader  *
//*   Automatically Generated by 3Dlabs GLSL ShaderGen   *
//*             http://developer.3dlabs.com              *
//*******************************************************/
vec4 Ambient;
vec4 Diffuse;
vec4 Specular;


void pointLight(in int i, in vec3 normal, in vec3 ecPosition3)
{
   float nDotVP;       // normal . light direction
   float nDotHV;       // normal . light half vector
   float pf;           // power factor
   float attenuation = 1.0;  // computed attenuation factor
   float d;            // distance from surface to light source
   vec3  VP;           // direction from surface to light position
   vec3  halfVector;   // direction of maximum highlights

   // Compute vector from surface to light position
   VP = vec3(V * lightPosition_worldspace[i]) - ecPosition3;

   // Compute distance between surface and light position
   d = length(VP);

   // Normalize the vector from surface to light position
   VP = normalize(VP);

#ifdef FLAT_SHADING
   // Compute attenuation
#if 0
   attenuation = 1.0 / (light_constantAttenuation[i] +
       light_linearAttenuation[i] * d +
       light_quadraticAttenuation[i] * d * d);
#endif
   attenuation = 1.0 / (light_quadraticAttenuation[i] * d * d);

   halfVector = normalize(VP + eye);

   nDotVP = max(0.0, dot(normal, VP));
   nDotHV = max(0.0, dot(normal, halfVector));

   if (nDotVP == 0.0)
   {
       pf = 0.0;
   }
   else
   {
       pf = pow(nDotHV, shininess);
   }
   Diffuse  += light_diffuse[i] * nDotVP * attenuation;
   Specular += light_specular[i] * pf * attenuation;
#else
   toLight_viewspace[i] = VP;
#endif
   Ambient  += light_ambient[i] * attenuation;
}

// directoinal light seems a bit off
void directionalLight(in int i, in vec3 normal)
{
   float nDotVP;         // normal . light direction
   //float nDotHV;         // normal . light half vector
   float pf;             // power factor

   vec3 lightVec =  normalize( mat3(V) * (vec3(lightPosition_worldspace[i]) / lightPosition_worldspace[i].w) );

#ifdef FLAT_SHADING
   nDotVP = max( 0.0, dot(normal, lightVec) );
#endif

   vec3 halfVector = normalize(lightVec + eye);

#ifdef FLAT_SHADING
   //float cosAlpha = clamp( dot(E, R), 0, 1 );

   nDotHV = max(  0.0, dot( normal, vec3(halfVector) )  );

   if (nDotVP == 0.0)
   {
       pf = 0.0;
   }
   else
   {
       pf = pow(nDotHV, shininess);
   }
   Specular += light_specular[i] * pf;
   Diffuse  += light_diffuse[i] * nDotVP;
#else
   lightVec_viewspace[i] = lightVec;
   halfVec_directionalLight_viewspace[i] = halfVector;
#endif
   Ambient  += light_ambient[i];


}


vec3 fnormal(void)
{
	normal_modelspace = vertexNormal_modelspace;
    // Compute the normal 
    vec3 normal = N * vertexNormal_modelspace;
    // vec3 normal = (MV * vec4(vertexNormal_modelspace, 0)).xyz; // not compatible with non-uniform scaling!
    normal = normalize(normal);

	// pass it on to the fragment shader:
	normal_viewspace = normal;

    return normal;
}

/*
void ftexgen(in vec3 normal, in vec4 ecPosition)
{

    gl_TexCoord[0].s = dot( gl_Vertex, gl_ObjectPlaneS[0] );
    gl_TexCoord[0].t = dot( gl_Vertex, gl_ObjectPlaneT[0] );
    gl_TexCoord[0].p = dot( gl_Vertex, gl_ObjectPlaneR[0] );
    gl_TexCoord[0].q = dot( gl_Vertex, gl_ObjectPlaneQ[0] );
}
*/

void light(in vec3 normal, in vec4 ecPosition, float alphaFade)
{
    vec4 color;
    vec3 ecPosition3;

    ecPosition3 = (vec3 (ecPosition)) / ecPosition.w;    

    // Clear the light intensity accumulators
    Ambient  = vec4 (0.0);
    Diffuse  = vec4 (0.0);
    Specular = vec4 (0.0);

    pointLight(0, normal, ecPosition3);

    //pointLight(1, normal, ecPosition3);

    //directionalLight(0, normal);

#ifdef FLAT_SHADING
    color = sceneColor +
      Ambient  * ambient +
      Diffuse  * diffuse;
    color += Specular * specular;
    color = clamp( color, 0.0, 1.1 );
    color_part = color;
#else
    color = sceneColor + Ambient * ambient;
	color_part = clamp(color, 0.0, 1.0);
#endif
}


void main (void)
{
    vec3  transformedNormal;
    float alphaFade = 1.0;

    // Eye-coordinate position of vertex, needed in various calculations
    vec4 ecPosition = MV * vec4(vertexPosition_modelspace,1);

    // Do fixed functionality vertex transform
    transformedNormal = fnormal();
    light(transformedNormal, ecPosition, alphaFade);
    //ftexgen(transformedNormal, ecPosition);
    gl_Position = MVP * vec4(vertexPosition_modelspace,1);
	UV = vertexUV;
}
